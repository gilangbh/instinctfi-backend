// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  walletAddress String   @unique
  username      String   @unique
  email         String?  @unique
  xp            Int      @default(0)
  totalRuns     Int      @default(0)
  winRate       Float    @default(0)
  reputation    Int      @default(0)
  isBanned      Boolean  @default(false)
  banReason     String?
  banExpiresAt  DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  badges        UserBadge[]
  runs          RunParticipant[]
  votes         Vote[]
  chatMessages  ChatMessage[]
  chatDownvotes ChatDownvote[]
  xpHistory     XpHistory[]

  @@map("users")
}

model Badge {
  id          String   @id @default(cuid())
  name        String   @unique
  emoji       String
  description String
  xpReward    Int      @default(0)
  createdAt   DateTime @default(now())

  // Relations
  userBadges UserBadge[]

  @@map("badges")
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  badgeId   String
  earnedAt  DateTime @default(now())

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge Badge @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@map("user_badges")
}

model Run {
  id                String      @id @default(cuid())
  status            RunStatus   @default(WAITING)
  tradingPair       String
  coin              String
  duration          Int         // in minutes
  votingInterval    Int         // in minutes
  minDeposit        Int         // in cents (USDC)
  maxDeposit        Int         // in cents (USDC)
  maxParticipants   Int         @default(100)
  totalPool         Int         @default(0) // in cents
  startingPool      Int         @default(0) // in cents
  currentRound      Int         @default(0)
  totalRounds       Int
  countdown         Int?        // seconds until next action
  startedAt         DateTime?
  endedAt           DateTime?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  // Relations
  participants RunParticipant[]
  trades       Trade[]
  votingRounds VotingRound[]
  chatMessages ChatMessage[]

  @@map("runs")
}

model RunParticipant {
  id            String   @id @default(cuid())
  runId         String
  userId        String
  depositAmount Int      // in cents
  withdrawn     Boolean  @default(false)
  finalShare    Int?     // in cents
  votesCorrect  Int      @default(0)
  totalVotes    Int      @default(0)
  joinedAt      DateTime @default(now())
  withdrawnAt   DateTime?

  // Relations
  run  Run  @relation(fields: [runId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([runId, userId])
  @@map("run_participants")
}

model Trade {
  id            String      @id @default(cuid())
  runId         String
  round         Int
  direction     TradeDirection
  leverage      Int
  positionSize  Int         // percentage of pool
  entryPrice    Decimal     @db.Decimal(20, 8)
  exitPrice     Decimal?    @db.Decimal(20, 8)
  pnl           Int         // in cents
  pnlPercentage Decimal     @db.Decimal(10, 4)
  executedAt    DateTime    @default(now())
  settledAt     DateTime?

  // Relations
  run Run @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@map("trades")
}

model Vote {
  id        String      @id @default(cuid())
  runId     String
  userId    String
  round     Int
  choice    VoteChoice
  votedAt   DateTime    @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([runId, userId, round])
  @@map("votes")
}

model VotingRound {
  id              String        @id @default(cuid())
  runId           String
  round           Int
  status          RoundStatus   @default(OPEN)
  timeRemaining   Int           // seconds
  leverage        Int
  positionSize    Int           // percentage
  currentPrice    Decimal       @db.Decimal(20, 8)
  priceChange24h  Decimal       @db.Decimal(10, 4)
  voteDistribution Json?        // {long: number, short: number, skip: number}
  startedAt       DateTime      @default(now())
  closedAt        DateTime?
  executedAt      DateTime?

  // Relations
  run Run @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@unique([runId, round])
  @@map("voting_rounds")
}

model ChatMessage {
  id        String   @id @default(cuid())
  runId     String
  userId    String
  message   String
  downvotes Int      @default(0)
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  run  Run  @relation(fields: [runId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("chat_messages")
}

model ChatDownvote {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@map("chat_downvotes")
}

model XpHistory {
  id        String   @id @default(cuid())
  userId    String
  amount    Int
  reason    String
  runId     String?
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("xp_history")
}

model PriceData {
  id        String   @id @default(cuid())
  symbol    String
  price     Decimal  @db.Decimal(20, 8)
  high      Decimal  @db.Decimal(20, 8)
  low       Decimal  @db.Decimal(20, 8)
  volume    Decimal  @db.Decimal(20, 8)
  timestamp DateTime @default(now())

  @@index([symbol, timestamp])
  @@map("price_data")
}

// Enums
enum RunStatus {
  WAITING
  ACTIVE
  SETTLING
  COOLDOWN
  ENDED
}

enum TradeDirection {
  LONG
  SHORT
  SKIP
}

enum VoteChoice {
  LONG
  SHORT
  SKIP
}

enum RoundStatus {
  OPEN
  CLOSED
  EXECUTING
  SETTLED
}

